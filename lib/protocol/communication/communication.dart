part of '../protocol.dart';

class Communications {
  Communications(this.ncpService);

  final NcpService ncpService;

  /// Sends all neigbors [devices] to receiver [receiverId]
  ///
  /// Needs [receiverId] and [senderId] for proper sending
  /// [devices] and [route] are required for proper routing
  void sendNeighborsToId({
    required String receiverId,
    required String ownId,
    required List<DiscoverDevice> devices,
    required MessageRoute route,
  }) {
    final List<Map> data = devices.map((device) => device.toMap()).toList();
    final Message message = Message(
      id: const Uuid().v4(),
      senderId: ownId,
      receiverId: receiverId,
      route: route,
      payload: data,
      messageType: MessageType.neighborsResponse,
    );
    handleMessage(message, ownId);
  }

  /// Request neighbors from [receiverId]
  ///
  /// Needs [ownId] and [route] for proper sending
  /// [route] shall be generated by [ConnectedDevicesGraph]
  void requestNeighbors({
    required String receiverId,
    required String ownId,
    required MessageRoute route,
  }) {
    final Message message = Message(
      id: const Uuid().v4(),
      senderId: ownId,
      receiverId: receiverId,
      route: route,
      payload: null,
      messageType: MessageType.neighborsRequest,
    );
    handleMessage(message, ownId);
  }

  ///Handles a message
  ///
  ///Needs [ownId] to put message in context to device
  ///Retruns the Messsge if device is last node in messageroute
  ///Function does not check if route is valid or operational because routing is always defined by the sender
  Message? handleMessage(Message message, String ownId) {
    if (message.receiverId == ownId) {
      return message;
    }
    final MessageRoute messageRoute = message.route;
    final List<String> routeDeviceIdList =
        messageRoute.map<String>((node) => node.deviceId).toList();
    final ownIndex = routeDeviceIdList.indexOf(ownId);
    sendMessageToId(message, routeDeviceIdList[ownIndex + 1]);
  }

  ///Sends [message] to [id]
  ///
  ///Uses [ncpService] defined in constructor to send message
  ///[message] and [id] are required
  Future<void> sendMessageToId(Message message, String id) async {
    await ncpService.sendMessageToId(message, id);
  }

  /// Inputpint for received messages
  /// 
  /// Needs [message] and [graph] to handle message
  String? messageInput(Message message, ConnectedDevicesGraph graph) {
    final messageForMe = handleMessage(message, message.senderId);
    if (messageForMe != null) {
      final ownId = messageForMe.receiverId;
      final senderId = messageForMe.senderId;
      if (messageForMe.messageType == MessageType.neighborsRequest) {
        messageForMe.interpret();
        sendNeighborsToId(
          receiverId: senderId,
          ownId: ownId,
          devices: graph.connectedDevices(),
          route: messageForMe.route.reversed.toList(),
        );
      } else if (messageForMe.messageType == MessageType.neighborsResponse) {
        final response = messageForMe.interpret() as List<DiscoverDevice>;
        graph.addDeviceWithAncestors(graph.me, response);
      } else if (messageForMe.messageType == MessageType.text) {
        return messageForMe.interpret() as String;
      }
    }
  }
}
